#include <TinyGPS++.h>
#include <SoftwareSerial.h>

// Debug Mode (uncomment for debugging)
// #define DEBUG

#ifdef DEBUG
#define DEBUG_PRINT(x) Serial.print(x)
#define DEBUG_PRINTLN(x) Serial.println(x)
#else
#define DEBUG_PRINT(x)
#define DEBUG_PRINTLN(x)
#endif

// GPS Module (NEO-M8N)
TinyGPSPlus gps;
#define GPS_SERIAL Serial1  // TX1=18, RX1=19

// HC-12 Wireless
#define HC12_SERIAL Serial2 // TX2=16, RX2=17

// Motor Control (L293D)
const int ENA = 12;  // PWM Left
const int ENB = 13;  // PWM Right
const int motorPin1 = 8;   // Left Dir1
const int motorPin2 = 9;   // Left Dir2
const int motorPin3 = 11;  // Right Dir1
const int motorPin4 = 10;  // Right Dir2

// System Parameters
const float MAX_SPEED_MPS = 0.3333;  // Max linear speed (m/s)
const float SPEED_50_PERCENT = 0.16665;
const float SPEED_40_PERCENT = 0.13332;
const float SPEED_30_PERCENT = 0.09999;
const float DELTA_T = 0.775; // seconds
const float DISTANCE_TRAVELED_DELTA_T = 0.1291925; // SPEED_50_PERCENT * DELTA_T

// Control variables
struct MotorCommand {
  int leftPWM;
  int rightPWM;
};
MotorCommand currentCommand = {0, 0};

void setup() {
  #ifdef DEBUG
  Serial.begin(115200);
  #endif
  
  GPS_SERIAL.begin(9600);  // GPS module
  HC12_SERIAL.begin(9600); // HC-12 module
  
  // Motor control pins
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorPin3, OUTPUT);
  pinMode(motorPin4, OUTPUT);
  
  DEBUG_PRINTLN("Robot Initialized");
}

void loop() {
  // Read GPS data
  while (GPS_SERIAL.available() > 0) {
    if (gps.encode(GPS_SERIAL.read())) {
      if (gps.location.isValid()) {
        sendGPSData();
      }
    }
  }
  
  // Check for incoming motor commands
  if (HC12_SERIAL.available() >= sizeof(MotorCommand)) {
    HC12_SERIAL.readBytes((byte*)&currentCommand, sizeof(MotorCommand));
    executeMotorCommand();
  }
  
  // Small delay to prevent flooding
  delay(50);
}

void sendGPSData() {
  // Package GPS data
  float latitude = gps.location.lat();
  float longitude = gps.location.lng();
  float speed = gps.speed.mps();
  float course = gps.course.deg();
  
  // Send data via HC-12
  HC12_SERIAL.print("GPS:");
  HC12_SERIAL.print(latitude, 6);
  HC12_SERIAL.print(",");
  HC12_SERIAL.print(longitude, 6);
  HC12_SERIAL.print(",");
  HC12_SERIAL.print(speed, 2);
  HC12_SERIAL.print(",");
  HC12_SERIAL.println(course, 2);
  
  DEBUG_PRINT("Sent GPS: ");
  DEBUG_PRINT(latitude, 6);
  DEBUG_PRINT(", ");
  DEBUG_PRINTLN(longitude, 6);
}

void executeMotorCommand() {
  // Set motor directions based on PWM sign
  // Left motor
  if (currentCommand.leftPWM > 0) {
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, LOW);
  } else if (currentCommand.leftPWM < 0) {
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
  } else {
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
  }
  
  // Right motor
  if (currentCommand.rightPWM > 0) {
    digitalWrite(motorPin3, HIGH);
    digitalWrite(motorPin4, LOW);
  } else if (currentCommand.rightPWM < 0) {
    digitalWrite(motorPin3, LOW);
    digitalWrite(motorPin4, HIGH);
  } else {
    digitalWrite(motorPin3, LOW);
    digitalWrite(motorPin4, LOW);
  }
  
  // Set PWM values (absolute value since direction is handled above)
  analogWrite(ENA, abs(currentCommand.leftPWM) * 2.55); // Convert 0-100 to 0-255
  analogWrite(ENB, abs(currentCommand.rightPWM) * 2.55);
  
  DEBUG_PRINT("Motor Cmd: L=");
  DEBUG_PRINT(currentCommand.leftPWM);
  DEBUG_PRINT(", R=");
  DEBUG_PRINTLN(currentCommand.rightPWM);
}
