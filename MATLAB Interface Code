classdef PathFollowingRobot < handle
    properties
        SerialPort
        Waypoints
        CurrentWaypointIndex
        FuzzySystem
    end
    
    methods
        function obj = PathFollowingRobot(portName)
            % Initialize serial port
            obj.SerialPort = serialport(portName, 115200);
            configureTerminator(obj.SerialPort, "LF");
            
            % Load waypoints (from your provided data)
            obj.Waypoints = [
                7.214941000, 124.249145000; 
                7.214940679, 124.249146167;
                % ... add all your waypoints here
                7.214914000, 124.249243000
            ];
            
            obj.CurrentWaypointIndex = 1;
            
            % Initialize fuzzy logic system
            obj.FuzzySystem = readfis('path_following.fis');
        end
        
        function run(obj)
            while true
                % Read GPS data from serial
                if obj.SerialPort.NumBytesAvailable > 0
                    data = readline(obj.SerialPort);
                    
                    if startsWith(data, "GPS:")
                        % Parse GPS data
                        gpsData = sscanf(data, "GPS:%f,%f,%f,%f");
                        currentLat = gpsData(1);
                        currentLon = gpsData(2);
                        speed = gpsData(3);
                        heading = gpsData(4);
                        
                        % Get current target waypoint
                        targetLat = obj.Waypoints(obj.CurrentWaypointIndex, 1);
                        targetLon = obj.Waypoints(obj.CurrentWaypointIndex, 2);
                        
                        % Calculate distance and heading errors
                        distanceError = obj.calculateDistance(currentLat, currentLon, targetLat, targetLon);
                        headingError = obj.calculateBearing(currentLat, currentLon, targetLat, targetLon) - heading;
                        
                        % Normalize heading error to [-180, 180]
                        headingError = mod(headingError + 180, 360) - 180;
                        
                        % Evaluate fuzzy logic
                        inputs = [distanceError, headingError];
                        outputs = evalfis(obj.FuzzySystem, inputs);
                        
                        % Send motor commands
                        motorCommand = sprintf("MOTOR:%d,%d", round(outputs(1)), round(outputs(2)));
                        writeline(obj.SerialPort, motorCommand);
                        
                        % Check if reached waypoint (within 2 meters)
                        if distanceError < 2
                            obj.CurrentWaypointIndex = obj.CurrentWaypointIndex + 1;
                            if obj.CurrentWaypointIndex > size(obj.Waypoints, 1)
                                disp("Reached final waypoint!");
                                writeline(obj.SerialPort, "MOTOR:0,0"); % Stop robot
                                break;
                            end
                        end
                    end
                end
                
                pause(0.1); % Small delay
            end
        end
        
        function distance = calculateDistance(~, lat1, lon1, lat2, lon2)
            % Haversine distance calculation (in meters)
            R = 6371000; % Earth radius in meters
            dLat = deg2rad(lat2 - lat1);
            dLon = deg2rad(lon2 - lon1);
            a = sin(dLat/2)^2 + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dLon/2)^2;
            c = 2 * atan2(sqrt(a), sqrt(1-a));
            distance = R * c;
        end
        
        function bearing = calculateBearing(~, lat1, lon1, lat2, lon2)
            % Calculate initial bearing between two points
            lat1 = deg2rad(lat1);
            lon1 = deg2rad(lon1);
            lat2 = deg2rad(lat2);
            lon2 = deg2rad(lon2);
            
            y = sin(lon2 - lon1) * cos(lat2);
            x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(lon2 - lon1);
            bearing = rad2deg(atan2(y, x));
            bearing = mod(bearing + 360, 360); % Normalize to 0-360
        end
    end
end
